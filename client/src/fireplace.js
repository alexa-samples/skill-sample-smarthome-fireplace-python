import * as THREE from "three";
import particleFire from "./three-particle-fire";

import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";

let AWS = require("aws-sdk");

let region = "us-east-1"; // TODO replace with your region if not us-east-1

AWS.config.region = region;
AWS.config.credentials = new AWS.CognitoIdentityCredentials({
  IdentityPoolId: "XXXXXXXXXX", // TODO replace with the id of the Cognito Identity Pool generated by the CloudFormation stack
});

let sqs = new AWS.SQS({
  apiVersion: "2012-11-05",
});
let sqsQueueUrl = "XXXXXXXXXX"; // TODO replace with the Amazon SQS Queue Url value generated by CloudFormation and found in your `setup.txt` file

particleFire.install({
  THREE: THREE,
});

var camera, scene, renderer;
var clock = new THREE.Clock();
var fireParticles;
var delta;

let defaultFireRadius = 0.5;
let defaultFireHeight = 1.5;
let defaultParticleCount = 1200;

init();
animate();

function init() {
  let FIREPARAMS = {
    colorOrange: 0xf58b00,
    colorYellow: 0xffad31,
    colorBlue: 0x0a67fc,

    positionDefault: {
      x: -2.5,
      y: 0.1,
      z: -0.1,
    },
    positionCandlelight: {
      x: -2.5,
      y: 0.8,
      z: -0.1,
    },

    flameOff: {
      fireRadius: 0.1,
      fireHeight: 0.1,
      particleCount: 10,
    },

    modeCandlelight: {
      fireRadius: 0.01,
      fireHeight: 1.6,
      particleCount: 30,
    },
    modeDefault: {
      fireRadius: defaultFireRadius,
      fireHeight: defaultFireHeight,
      particleCount: defaultParticleCount,
    },
    modeIceFlame: {
      fireRadius: 0.5,
      fireHeight: 1.2,
      particleCount: 400,
    },

    rangeLow: {
      fireRadius: 0.2,
      fireHeight: defaultFireHeight,
      particleCount: defaultParticleCount,
    },

    rangeNormal: {
      fireRadius: defaultFireRadius,
      fireHeight: defaultFireHeight,
      particleCount: defaultParticleCount,
    },

    rangeHigh: {
      fireRadius: 0.9,
      fireHeight: defaultFireHeight,
      particleCount: defaultParticleCount,
    },
  };

  // SQS
  function sqsRead() {
    let receiveParams = {
      QueueUrl: sqsQueueUrl,
      AttributeNames: ["All"],
      MessageAttributeNames: ["All"],
      MaxNumberOfMessages: 1,
      VisibilityTimeout: 1,
      WaitTimeSeconds: 20,
    };

    return sqs.receiveMessage(receiveParams, function (err, data) {
      if (err) {
        console.log("Error retrieving SQS message", err);
      } else if (data.Messages && data.Messages.length > 0) {
        if (typeof data.Messages != "undefined") {
          let body = JSON.parse(data.Messages[0].Body);
          document.getElementById("api-directive-payload").innerHTML =
            "<pre>" + JSON.stringify(body, null, 2) + "</pre>";

          let endpoint_id = body.endpointId;
          let namespace = body.namespace;

          if (endpoint_id === "fireplace-01" || endpoint_id === "fireplace") {
            // PowerController
            if (namespace === "Alexa.PowerController") {
              let value = body.value;
              document.getElementById("api-interface").innerHTML =
                "Alexa.PowerController";
              if (value === "OFF") {
                fireParticles.geometry = new particleFire.Geometry(
                  FIREPARAMS.flameOff.fireRadius,
                  FIREPARAMS.flameOff.fireHeight,
                  FIREPARAMS.flameOff.particleCount
                );
                document.getElementById("api-state").innerHTML = "TurnOff";
              } else {
                document.getElementById("api-state").innerHTML = "TurnOn";
                fireParticles.geometry = new particleFire.Geometry(
                  FIREPARAMS.modeDefault.fireRadius,
                  FIREPARAMS.modeDefault.fireHeight,
                  FIREPARAMS.modeDefault.particleCount
                );
              }

            // ModeController
            } else if (namespace === "Alexa.ModeController") {
              let modeValue = body.value;
              document.getElementById("api-interface").innerHTML =
                "Alexa.ModeController";

              if (modeValue === "FlameType.Candle") {
                document.getElementById("api-state").innerHTML =
                  "FlameType.Candle";

                fireParticles.position.set(
                  FIREPARAMS.positionCandlelight.x,
                  FIREPARAMS.positionCandlelight.y,
                  FIREPARAMS.positionCandlelight.z
                );
                fireParticles.geometry = new particleFire.Geometry(
                  FIREPARAMS.modeCandlelight.fireRadius,
                  FIREPARAMS.modeCandlelight.fireHeight,
                  FIREPARAMS.modeCandlelight.particleCount
                );
                fireParticles.material.color.setHex(FIREPARAMS.colorYellow);
              } else if (modeValue === "FlameType.IceFlame") {
                document.getElementById("api-state").innerHTML =
                  "FlameType.IceFlame";

                fireParticles.position.set(
                  FIREPARAMS.positionDefault.x,
                  FIREPARAMS.positionDefault.y,
                  FIREPARAMS.positionDefault.z
                );
                fireParticles.geometry = new particleFire.Geometry(
                  FIREPARAMS.modeIceFlame.fireRadius,
                  FIREPARAMS.modeIceFlame.fireHeight,
                  FIREPARAMS.modeIceFlame.particleCount
                );
                fireParticles.material.color.setHex(FIREPARAMS.colorBlue);
              } else if (modeValue === "FlameType.Campfire") {
                document.getElementById("api-state").innerHTML =
                  "FlameType.Campfire";

                fireParticles.position.set(
                  FIREPARAMS.positionDefault.x,
                  FIREPARAMS.positionDefault.y,
                  FIREPARAMS.positionDefault.z
                );
                fireParticles.geometry = new particleFire.Geometry(
                  FIREPARAMS.modeDefault.fireRadius,
                  FIREPARAMS.modeDefault.fireHeight,
                  FIREPARAMS.modeDefault.particleCount
                );
                fireParticles.material.color.setHex(FIREPARAMS.colorYellow);
              }

            // ColorController
            } else if (namespace === "Alexa.ColorController") {
              document.getElementById("api-interface").innerHTML =
                "Alexa.ColorController";

              let hexColor = getHexFromHSB(body.value);
              fireParticles.material.color.setHex(hexColor);
              document.getElementById("api-state").innerHTML = hexColor;

            // RangeController
            } else if (namespace === "Alexa.RangeController") {
              document.getElementById("api-interface").innerHTML =
                "Alexa.RangeController";
              let range = body.value;
              if (range === 1) {
                document.getElementById("api-state").innerHTML = "Low";

                fireParticles.geometry = new particleFire.Geometry(
                  FIREPARAMS.rangeLow.fireRadius,
                  FIREPARAMS.rangeLow.fireHeight,
                  FIREPARAMS.rangeLow.particleCount
                );
              } else if (range === 2) {
                document.getElementById("api-state").innerHTML = "Normal";
                fireParticles.geometry = new particleFire.Geometry(
                  FIREPARAMS.modeDefault.fireRadius,
                  FIREPARAMS.modeDefault.fireHeight,
                  FIREPARAMS.modeDefault.particleCount
                );
              } else if (range === 3) {
                document.getElementById("api-state").innerHTML = "High";
                fireParticles.geometry = new particleFire.Geometry(
                  FIREPARAMS.rangeHigh.fireRadius,
                  FIREPARAMS.rangeHigh.fireHeight,
                  FIREPARAMS.rangeHigh.particleCount
                );
              }
            } else {
              console.log("Unhandled namespace " + namespace);
            }
          }

          sqsDelete(data.Messages[0].ReceiptHandle);
        }
      }

      setTimeout(sqsRead, 1000);
    });
  }

  function sqsDelete(receiptHandle) {
    var deleteParams = {
      QueueUrl: sqsQueueUrl,
      ReceiptHandle: receiptHandle,
    };

    return sqs.deleteMessage(deleteParams, function (err, data) {
      if (err) {
        console.log("Delete Error", err);
      } else {
        console.log("Message Deleted", data);
      }
    });
  }

  // ThreeJS Scene
  var width = window.innerWidth;
  var height = window.innerHeight;

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 1000);
  camera.position.set(-8.0, 3.0, 8.0);
  scene.add(camera);

  var ambientLight = new THREE.AmbientLight(0xffffff, 1.4);
  scene.add(ambientLight);

  var pointLight = new THREE.PointLight(0xe6e6e6, 1, 100);
  pointLight.position.set(50, 250, 250);
  scene.add(pointLight);

  renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true,
  });

  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = false;

  var geometry0 = new particleFire.Geometry(
    FIREPARAMS.modeDefault.fireRadius,
    FIREPARAMS.modeDefault.fireHeight,
    FIREPARAMS.modeDefault.particleCount
  );
  var material0 = new particleFire.Material({
    color: FIREPARAMS.colorOrange,
  });

  var material1 = new particleFire.Material({
    color: FIREPARAMS.colorOrange,
  });

  var material0 = new particleFire.Material({
    color: FIREPARAMS.colorYellow,
  });

  material0.setPerspective(camera.fov, height);
  fireParticles = new THREE.Points(geometry0, material0);
  fireParticles.position.set(
    FIREPARAMS.positionDefault.x,
    FIREPARAMS.positionDefault.y,
    FIREPARAMS.positionDefault.z
  );
  scene.add(fireParticles);

  const controls = new OrbitControls(camera, renderer.domElement);

  document.body.appendChild(renderer.domElement);

  var mtlLoader = new MTLLoader();
  mtlLoader.setPath("./src/model/");
  var url = "modernFireplace.mtl";
  mtlLoader.load(url, function (materials) {
    materials.preload();

    var objLoader = new OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath("/src/model/");
    objLoader.load(
      "modernFireplace.obj",
      function (object) {
        object.scale.x = 1.0;
        object.scale.y = 1.0;
        object.scale.z = 1.0;
        object.position.set(-2.5, 0.0, 0);
        scene.add(object);
      },
      onProgress,
      onError
    );
  });

  var onError = function () {};
  var onProgress = function (xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = (xhr.loaded / xhr.total) * 100;
      console.log(Math.round(percentComplete, 2) + "% downloaded");
    }
  };

  sqsRead();

  window.addEventListener("resize", onWindowResize, false);
  fireParticles.material.setPerspective(camera.fov, height);
}

function getHexFromHSB(hsbValue) {
  let h = hsbValue.hue;
  let s = hsbValue.saturation;
  let b = hsbValue.brightness;

  var l = ((2 - s) * b) / 2;
  if (l != 0) {
    if (l == 1) {
      s = 0;
    } else if (l < 0.5) {
      s = (s * b) / (l * 2);
    } else {
      s = (s * b) / (2 - l * 2);
    }
  }

  let hex = hslToHex(h, s * 100, l * 100);
  return hex;
}

function hslToHex(h, s, l) {
  h /= 360;
  s /= 100;
  l /= 100;
  let r, g, b;
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  const toHex = (x) => {
    const hex = Math.round(x * 255).toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  };
  return `0x${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function onWindowResize() {
  var width = window.innerWidth;
  var height = window.innerHeight;

  camera.aspect = width / height;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);

  delta = clock.getDelta();
  fireParticles.material.update(delta * 0.66);

  renderer.clear();
  renderer.render(scene, camera);
}
